{"name":"Pedal-tx","tagline":"A Java 8 based idiomatic JPA DAO framework. Let the examples say the rest.","body":"Pedal-tx\r\n=====\r\n\r\nPeda-tx, a member of the Pedal family ([pedal-dialect](https://github.com/eclecticlogic/pedal-dialect), [pedal-loader](https://github.com/eclecticlogic/pedal-loader)), is a Java 8 based idiomatic JPA DAO framework. \r\n\r\n## Feature Highlights\r\n\r\n- Transaction management\r\n\t- Lambda based transaction boundary\r\n\t- Transaction attached objects\r\n\t- Transaction attached jobs\r\n- DAO shell with predefined functions\r\n    - Fluent interface for HQL/JQL queries\r\n    - Simple integration with QueryDSL\t\r\n    - Hooks to set insert/update date/time automatically\r\n    - DAO registry function for dynamic CRUD operations\r\n\t \r\n# Getting started\r\n\r\nDownload the Pedal jar from Maven central:\r\n\r\n```\r\n\t<groupId>com.eclecticlogic</groupId>\r\n\t<artifactId>pedal</artifactId>\r\n\t<version>1.5.0</version>\r\n```\r\n\r\nMinimum dependencies that you need to provide in your application:\r\n\r\n1. slf4j (over logback or log4j) v1.7.7 or higher\r\n2. spring-tx, spring-context and spring-orm v4.0 or higher\r\n4. hibernate-core and hibernate-entitymanager 4.3 or higher.\r\n5. JDBC4 compliant driver and connection pool manager (BoneCP recommended).\r\n\r\n# Configuration\r\n\r\n### Setting up Spring beans \r\n\r\nPedal's transaction object requires an implementation of PlatformTransactionManager which Spring's JPATransactionManager (and JTATransactionManager) provide. However, to enable advanced features, we recommend using Pedal's JPATransactionWrapper (which derives from JPATransactionManager). After wiring up your usual suspect JPA/Hibernate Spring beans, create and instance of Pedal's TransactionImpl and set the platformTransactionManager property to the JPATransactionWrapper bean reference (example below in the next section on DAO wiring).\r\n\r\n### Wiring up DAOs\r\n\r\nPedal DAO classes should derive from the AbstractDAO base class. It is recommended that you introduce an application specific parent class that dervices from AbstractDAO and have your DAOs derive from the application specific classes. The minimum requirement for a DAO class is to provide the implementation of the abstract getEntityClass() method:\r\n\r\n```\r\n    public Class<E> getEntityClass();\r\n```\r\nThis is usually as simple as (for the Entity class Student.java; the code is necessitated by the limitations of generics in Java):\r\n\r\n```\r\n\tpublic class StudentDAO extends AbstractDAO<Student> { \r\n    \t@override\r\n\t    public Class<Student> getEntityClass() {\r\n    \t\treturn Student.class;\r\n\t    }\r\n\t}\r\n```\r\n\r\nThe DAO should also be provided with a reference to an EntityManager. This can be done as part of Spring wiring or in code as:\r\n\r\n```\r\n    @Override\r\n    @PersistenceContext\r\n    public void setEntityManager(EntityManager entityManager) {\r\n        super.setEntityManager(entityManager);\r\n    }\r\n```\r\n\r\nThe StudentDAO now supports basic CRUD operations and provides a fluent API for selects.  \r\n\r\nThe typical Spring based wiring of a DAO (with an application specific parent DAO called AppDAO) looks like this:\r\n\r\n```\r\n\t<bean id=\"ptf\" class=\"com.eclecticlogic.pedal.impl.JPATransactionWrapper\">\r\n\t\t<property name=\"entityManagerFactory\" ref=\"emf\" />\r\n\t</bean>\r\n\r\n\t<bean id=\"tx\" class=\"com.eclecticlogic.pedal.impl.TransactionImpl\">\r\n\t\t<property name=\"platformTransactionManager\" ref=\"ptf\" />\r\n\t</bean>\r\n\t\r\n    <bean id=\"abstractDAO\" abstract=\"true\" class=\"com.myapp.AppDAO\">\r\n\t\t<property name=\"transaction\" ref=\"tx\" />\r\n\t\t<property name=\"providerAccess\" ref=\"hibernateProviderAccess\" />\r\n\t</bean>\r\n\r\n\t<bean parent=\"abstractDAO\" class=\"com.eclecticlogic.pedal.test.dm.dao.StudentDAO\" />\r\n``` \r\n\r\n# Usage\r\n\r\n### Create, Update, Delete\r\n\r\nTo create an entity, simply call the DAO's create method. \r\n\r\n```\r\n    Student student = new Student();\r\n    // set various attributes\r\n    studentDAO.create(student);\r\n    // also studentDAO.create(student1, student2 ...);\r\n```\r\nSimilarly, to update an entity call the update(entity) method and for deleting the delete(entity) method.\r\n\r\n### Queries\r\n\r\nWe strongly recommend that all queries be contained within the DAO class. To write a select query, you can use CritieriaQuery objects, HQL, JPA-QL or native SQL. Here is a simple HQL query implementation in the StudentDAO:\r\n\r\n```\r\n    public List<Student> findByGradeAndGPARange(int grade, float gpaLow, float gpaHigh) {\r\n        return select(\"from Student where grade = :grade and gpa between :gpaLow and :gpaHigh\") //\r\n                .bind(\"grade\", grade) //\r\n                .bind(\"gpaLow\", gpaLow) //\r\n                .bind(\"gpaHigh\", gpaHigh) //\r\n                .list();\r\n    }\r\n```\r\n\r\nYou can use the get() method to return just one result (it returns Optional<T>) or the \"Optional<R> scalar()\" method to get a scalar result back or the \"List<R> scalarList()\" method to get a scalar list back. You can also use the \"returning(int maxResults)\" and \"startingAt(int startPosition)\" methods to page through the result lists. You can also specify locking mode with the \"using(LockModeType lock)\" method. The select() method of the Abstract DAO has overloaded variants to accept CriteriaQuery query objects and native queries. \r\n\r\n### Update Queries\r\n\r\nThe update(query) api is similar to the select and can be used to execute updates and deletes. Here is an example:\r\n\r\n```\r\n   public int graduateAboveGPA(float gpa) {\r\n\t\tupdate(\"update Student set grade = grade + 1 where gpa >= :gpa\") //\r\n                .bind(\"gpa\", gpa) //\r\n                .update(); // returns rows updated.  \r\n\t}\r\n```\r\n\r\n### Inserted/Updated date-time setting\r\n\r\nPedal-tx's `AbstractDAO` can automatically set inserted/updated date time on your objects (i.e., on the client-side for use-cases where this is appropriate or preferred to database side operation). To enable this functionality, set the `DateTimeProvider` property of `AbstractDAO` by calling the setter with a `DateTimeProvider` or derivative. The default implementation `com.eclecticlogic.pedal.dm.DateTimeProvider` looks for properties named `insertedOn` or `updatedOn`. It is recommended that your application specific base derivative of `AbstractDAO` set the provider and call `AbstractDAO.init()`. \r\n\r\n# Transaction Management\r\n\r\n### Transactions\r\n\r\nThe Pedal Transaction object allows programmatic transaction delineation alongside Spring's @Transactional annotation. To execute a block of code in a transaction, simply get a reference to an injected transaction reference (you can supply the transaction reference to the AbstractDAO) and call either the run method (no return value) or exec method. The run has variants that takes a Consumer or Runnable. The consumer gets a reference to a \"Context\" instance. The exec can take a Supplier (no Context reference) or a Function that takes a Context and returns a value. The following snipper shows the transaction in action:\r\n\r\n```\r\n   public void createStudentAndScore() {\r\n       getTransaction().run(() -> {\r\n           Student student = new Student();\r\n           student...\r\n           getStudentDAO.create(student);\r\n           \r\n           Score score = new Score();\r\n           score.setStudent(student);\r\n           ...\r\n           getScoreDAO().create(score);\r\n       });\r\n   }\r\n```\r\n\r\n### Transaction attached objects\r\n\r\nPedal allows you to attach data and jobs to the current transaction. To enable this feature, you must use Pedal's JPATransactionWrapper instead of Spring's JPATransactionManager. Here is an example of setting and retrieving transaction attached data:\r\n\r\n```\r\n\tpublic void setupData() {\r\n\t    getTransaction().run(context -> {\r\n           \r\n           context.put(\"myKey\", someObject);\r\n           verifyData();           \r\n        });\r\n    }\r\n    \r\n    public void verifyData() {\r\n        getTransaction().run(context -> {\r\n           \r\n            assert context.get(\"myKey\") == someObject;\r\n        });\r\n    }\r\n```\r\n \r\n### Transaction attached jobs\r\n\r\nTransaction attached jobs allow you to fire code either just before and just after the transaction commits. The after-commit is only called if the transaction successfully commits.\r\n\r\n```\r\n   public void jobFun() {\r\n      getTransaction().run(context -> {\r\n           \r\n            context.beforeCommit((DataContext dc) -> {\r\n                // This is called before the commit. \r\n            }\r\n            \r\n            context.afterCommit((DataContext dc) -> {\r\n            \t// The data is now in the database and visible to other transactions.\r\n            }           \r\n       });\r\n   }\r\n```\r\n\r\n# Release notes\r\n\r\n### 1.5.0\r\n\r\n- Major refactoring. Pedal is now pedal-tx, pedal-dialect and pedal-loader; three separate projects. Dialect and loader specific functionality have been separated to allow for more granular use.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}