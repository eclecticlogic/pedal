<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Pedal-tx by eclecticlogic</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Pedal-tx</h1>
          <h2>A Java 8 based idiomatic JPA DAO framework. Let the examples say the rest.</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/eclecticlogic/pedal-tx/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/eclecticlogic/pedal-tx/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/eclecticlogic/pedal-tx" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a id="pedal-tx" class="anchor" href="#pedal-tx" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pedal-tx</h1>

<p>Peda-tx, a member of the Pedal family (<a href="https://github.com/eclecticlogic/pedal-dialect">pedal-dialect</a>, <a href="https://github.com/eclecticlogic/pedal-loader">pedal-loader</a>), is a Java 8 based idiomatic JPA DAO framework. </p>

<h2>
<a id="feature-highlights" class="anchor" href="#feature-highlights" aria-hidden="true"><span class="octicon octicon-link"></span></a>Feature Highlights</h2>

<ul>
<li>Transaction management

<ul>
<li>Lambda based transaction boundary</li>
<li>Transaction attached objects</li>
<li>Transaction attached jobs</li>
</ul>
</li>
<li>DAO shell with predefined functions

<ul>
<li>Fluent interface for HQL/JQL queries</li>
<li>Simple integration with QueryDSL<br>
</li>
<li>Hooks to set insert/update date/time automatically</li>
<li>DAO registry function for dynamic CRUD operations</li>
</ul>
</li>
</ul>

<h1>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting started</h1>

<p>Download the Pedal jar from Maven central:</p>

<pre><code>    &lt;groupId&gt;com.eclecticlogic&lt;/groupId&gt;
    &lt;artifactId&gt;pedal&lt;/artifactId&gt;
    &lt;version&gt;1.5.0&lt;/version&gt;
</code></pre>

<p>Minimum dependencies that you need to provide in your application:</p>

<ol>
<li>slf4j (over logback or log4j) v1.7.7 or higher</li>
<li>spring-tx, spring-context and spring-orm v4.0 or higher</li>
<li>hibernate-core and hibernate-entitymanager 4.3 or higher.</li>
<li>JDBC4 compliant driver and connection pool manager (BoneCP recommended).</li>
</ol>

<h1>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuration</h1>

<h3>
<a id="setting-up-spring-beans" class="anchor" href="#setting-up-spring-beans" aria-hidden="true"><span class="octicon octicon-link"></span></a>Setting up Spring beans</h3>

<p>Pedal's transaction object requires an implementation of PlatformTransactionManager which Spring's JPATransactionManager (and JTATransactionManager) provide. However, to enable advanced features, we recommend using Pedal's JPATransactionWrapper (which derives from JPATransactionManager). After wiring up your usual suspect JPA/Hibernate Spring beans, create and instance of Pedal's TransactionImpl and set the platformTransactionManager property to the JPATransactionWrapper bean reference (example below in the next section on DAO wiring).</p>

<h3>
<a id="wiring-up-daos" class="anchor" href="#wiring-up-daos" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wiring up DAOs</h3>

<p>Pedal DAO classes should derive from the AbstractDAO base class. It is recommended that you introduce an application specific parent class that dervices from AbstractDAO and have your DAOs derive from the application specific classes. The minimum requirement for a DAO class is to provide the implementation of the abstract getEntityClass() method:</p>

<pre><code>    public Class&lt;E&gt; getEntityClass();
</code></pre>

<p>This is usually as simple as (for the Entity class Student.java; the code is necessitated by the limitations of generics in Java):</p>

<pre><code>    public class StudentDAO extends AbstractDAO&lt;Student&gt; { 
        @override
        public Class&lt;Student&gt; getEntityClass() {
            return Student.class;
        }
    }
</code></pre>

<p>The DAO should also be provided with a reference to an EntityManager. This can be done as part of Spring wiring or in code as:</p>

<pre><code>    @Override
    @PersistenceContext
    public void setEntityManager(EntityManager entityManager) {
        super.setEntityManager(entityManager);
    }
</code></pre>

<p>The StudentDAO now supports basic CRUD operations and provides a fluent API for selects.  </p>

<p>The typical Spring based wiring of a DAO (with an application specific parent DAO called AppDAO) looks like this:</p>

<pre><code>    &lt;bean id="ptf" class="com.eclecticlogic.pedal.impl.JPATransactionWrapper"&gt;
        &lt;property name="entityManagerFactory" ref="emf" /&gt;
    &lt;/bean&gt;

    &lt;bean id="tx" class="com.eclecticlogic.pedal.impl.TransactionImpl"&gt;
        &lt;property name="platformTransactionManager" ref="ptf" /&gt;
    &lt;/bean&gt;

    &lt;bean id="abstractDAO" abstract="true" class="com.myapp.AppDAO"&gt;
        &lt;property name="transaction" ref="tx" /&gt;
        &lt;property name="providerAccess" ref="hibernateProviderAccess" /&gt;
    &lt;/bean&gt;

    &lt;bean parent="abstractDAO" class="com.eclecticlogic.pedal.test.dm.dao.StudentDAO" /&gt;
</code></pre>

<h1>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h1>

<h3>
<a id="create-update-delete" class="anchor" href="#create-update-delete" aria-hidden="true"><span class="octicon octicon-link"></span></a>Create, Update, Delete</h3>

<p>To create an entity, simply call the DAO's create method. </p>

<pre><code>    Student student = new Student();
    // set various attributes
    studentDAO.create(student);
    // also studentDAO.create(student1, student2 ...);
</code></pre>

<p>Similarly, to update an entity call the update(entity) method and for deleting the delete(entity) method.</p>

<h3>
<a id="queries" class="anchor" href="#queries" aria-hidden="true"><span class="octicon octicon-link"></span></a>Queries</h3>

<p>We strongly recommend that all queries be contained within the DAO class. To write a select query, you can use CritieriaQuery objects, HQL, JPA-QL or native SQL. Here is a simple HQL query implementation in the StudentDAO:</p>

<pre><code>    public List&lt;Student&gt; findByGradeAndGPARange(int grade, float gpaLow, float gpaHigh) {
        return select("from Student where grade = :grade and gpa between :gpaLow and :gpaHigh") //
                .bind("grade", grade) //
                .bind("gpaLow", gpaLow) //
                .bind("gpaHigh", gpaHigh) //
                .list();
    }
</code></pre>

<p>You can use the get() method to return just one result (it returns Optional) or the "Optional scalar()" method to get a scalar result back or the "List scalarList()" method to get a scalar list back. You can also use the "returning(int maxResults)" and "startingAt(int startPosition)" methods to page through the result lists. You can also specify locking mode with the "using(LockModeType lock)" method. The select() method of the Abstract DAO has overloaded variants to accept CriteriaQuery query objects and native queries. </p>

<h3>
<a id="update-queries" class="anchor" href="#update-queries" aria-hidden="true"><span class="octicon octicon-link"></span></a>Update Queries</h3>

<p>The update(query) api is similar to the select and can be used to execute updates and deletes. Here is an example:</p>

<pre><code>   public int graduateAboveGPA(float gpa) {
        update("update Student set grade = grade + 1 where gpa &gt;= :gpa") //
                .bind("gpa", gpa) //
                .update(); // returns rows updated.  
    }
</code></pre>

<h3>
<a id="insertedupdated-date-time-setting" class="anchor" href="#insertedupdated-date-time-setting" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inserted/Updated date-time setting</h3>

<p>Pedal-tx's <code>AbstractDAO</code> can automatically set inserted/updated date time on your objects (i.e., on the client-side for use-cases where this is appropriate or preferred to database side operation). To enable this functionality, set the <code>DateTimeProvider</code> property of <code>AbstractDAO</code> by calling the setter with a <code>DateTimeProvider</code> or derivative. The default implementation <code>com.eclecticlogic.pedal.dm.DateTimeProvider</code> looks for properties named <code>insertedOn</code> or <code>updatedOn</code>. It is recommended that your application specific base derivative of <code>AbstractDAO</code> set the provider and call <code>AbstractDAO.init()</code>. </p>

<h1>
<a id="transaction-management" class="anchor" href="#transaction-management" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transaction Management</h1>

<h3>
<a id="transactions" class="anchor" href="#transactions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transactions</h3>

<p>The Pedal Transaction object allows programmatic transaction delineation alongside Spring's <a href="https://github.com/Transactional" class="user-mention">@Transactional</a> annotation. To execute a block of code in a transaction, simply get a reference to an injected transaction reference (you can supply the transaction reference to the AbstractDAO) and call either the run method (no return value) or exec method. The run has variants that takes a Consumer or Runnable. The consumer gets a reference to a "Context" instance. The exec can take a Supplier (no Context reference) or a Function that takes a Context and returns a value. The following snipper shows the transaction in action:</p>

<pre><code>   public void createStudentAndScore() {
       getTransaction().run(() -&gt; {
           Student student = new Student();
           student...
           getStudentDAO.create(student);

           Score score = new Score();
           score.setStudent(student);
           ...
           getScoreDAO().create(score);
       });
   }
</code></pre>

<h3>
<a id="transaction-attached-objects" class="anchor" href="#transaction-attached-objects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transaction attached objects</h3>

<p>Pedal allows you to attach data and jobs to the current transaction. To enable this feature, you must use Pedal's JPATransactionWrapper instead of Spring's JPATransactionManager. Here is an example of setting and retrieving transaction attached data:</p>

<pre><code>    public void setupData() {
        getTransaction().run(context -&gt; {

           context.put("myKey", someObject);
           verifyData();           
        });
    }

    public void verifyData() {
        getTransaction().run(context -&gt; {

            assert context.get("myKey") == someObject;
        });
    }
</code></pre>

<h3>
<a id="transaction-attached-jobs" class="anchor" href="#transaction-attached-jobs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transaction attached jobs</h3>

<p>Transaction attached jobs allow you to fire code either just before and just after the transaction commits. The after-commit is only called if the transaction successfully commits.</p>

<pre><code>   public void jobFun() {
      getTransaction().run(context -&gt; {

            context.beforeCommit((DataContext dc) -&gt; {
                // This is called before the commit. 
            }

            context.afterCommit((DataContext dc) -&gt; {
                // The data is now in the database and visible to other transactions.
            }           
       });
   }
</code></pre>

<h1>
<a id="release-notes" class="anchor" href="#release-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Release notes</h1>

<h3>
<a id="150" class="anchor" href="#150" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.5.0</h3>

<ul>
<li>Major refactoring. Pedal is now pedal-tx, pedal-dialect and pedal-loader; three separate projects. Dialect and loader specific functionality have been separated to allow for more granular use.</li>
</ul>
        </section>

        <footer>
          Pedal-tx is maintained by <a href="https://github.com/eclecticlogic">eclecticlogic</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>